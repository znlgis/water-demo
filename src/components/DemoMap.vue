<!--
  OpenLayers地图演示组件
  功能：
  1. 展示基于OpenLayers的交互式地图
  2. 动态加载GeoServer图层和图层组
  3. 提供图层控制、缩放、上下文菜单等地图控件
-->
<template>
  <!-- OpenLayers地图容器 -->
  <Map.OlMap id="map" ref="mapRef" :controls="[]">
    <!-- 地图视图配置：中心点、投影、缩放级别 -->
    <Map.OlView
        ref="view"
        :center="center"
        :projection="projection"
        :zoom="zoom"
    />

    <!-- 动态图层组：通过GeoServer API获取的图层组 -->
    <Layers.OlLayerGroup v-for="group in dynamicLayerGroupList" :key="group.name" :title="group.name"
                         :visible="group.visible">
      <!-- 图层组内的瓦片图层 -->
      <Layers.OlTileLayer v-for="layer in group.layers" :key="layer.name" :title="layer.name" :visible="layer.visible">
        <Sources.OlSourceTileWms :layers="layer.name" :url="layer.url"/>
      </Layers.OlTileLayer>
    </Layers.OlLayerGroup>

    <!-- 动态图层：通过GeoServer API获取的单独图层 -->
    <Layers.OlTileLayer v-for="layer in dynamicLayerList" :key="layer.name" :title="layer.name"
                        :visible="layer.visible">
      <Sources.OlSourceTileWms :layers="layer.name" :url="layer.url"/>
    </Layers.OlTileLayer>

    <!-- 地图控件：图层切换器（展开状态） -->
    <MapControls.OlLayerswitcherControl :collapsed="false"/>

    <!-- 地图控件：缩放控制 -->
    <MapControls.OlZoomControl/>

    <!-- 地图控件：右键上下文菜单 -->
    <MapControls.OlContextMenuControl/>

    <!-- 地图控件：比例尺 -->
    <MapControls.OlScalelineControl/>

  </Map.OlMap>
  
  <!-- AI对话框按钮 -->
  <button class="ai-chat-button" @click="toggleChatDialog">
    🤖 AI助手
  </button>
  
  <!-- AI对话框组件 -->
  <AiChatDialog 
    :visible="chatDialogVisible"
    @close="closeChatDialog"
    @geoJsonReceived="handleGeoJsonReceived"
  />
</template>

<script lang="ts" setup>
//Vue组合式API函数
import {onMounted, ref} from "vue";
// 导入OpenLayers Map类型定义
import type MapRef from "ol/Map";
// 导入Vue3-OpenLayers组件
import {Layers, Map, MapControls, Sources} from "vue3-openlayers";
// 导入GeoServer REST API类
import GeoServerRestApi from '../geoserver/GeoServerRestApi';
// 导入AI对话框组件
import AiChatDialog from './AiChatDialog.vue';
// 导入OpenLayers用于GeoJSON处理
import VectorLayer from 'ol/layer/Vector';
import VectorSource from 'ol/source/Vector';
import GeoJSON from 'ol/format/GeoJSON';
import {Style, Stroke, Fill, Circle} from 'ol/style';

// ========== 响应式数据定义 ==========

/** 地图中心点坐标 [经度, 纬度] */
const center = ref([112, 25]);

/** 地图投影坐标系 */
const projection = ref("EPSG:4326");

/** 地图初始缩放级别 */
const zoom = ref(10);

/** 动态图层列表：存储从GeoServer获取的单独图层 */
const dynamicLayerList = ref([]);

/** 动态图层组列表：存储从GeoServer获取的图层组 */
const dynamicLayerGroupList = ref([]);

/** 地图实例引用 */
const mapRef = ref<MapRef | null>(null);

// ========== AI对话框相关数据 ==========

/** AI对话框显示状态 */
const chatDialogVisible = ref(false);

/** GeoJSON向量图层 */
let geoJsonLayer = null;

// ========== 生命周期钩子 ==========

/**
 * 组件挂载后执行
 * 主要功能：从GeoServer加载图层和图层组数据
 */
onMounted(async () => {
  try {
    // 创建GeoServer REST API实例
    let geoServerRestApi = new GeoServerRestApi();

    // ========== 加载单独图层 ==========
    
    // 获取所有图层列表
    let layers = await geoServerRestApi.layers.getLayers();
    let layerList = layers.layers.layer;
    
    // 遍历图层列表，配置每个图层
    layerList.forEach((layer: any) => {
      let layerName = layer.name;
      
      // 特殊处理：ne:countries图层默认显示，其他图层默认隐藏
      if (layerName === 'postgis:counties_china') {
        dynamicLayerList.value.push({
          name: layerName,                 // 图层名称
          url: `/geoserver/wms`,          // WMS服务URL
          visible: true,                  // 默认可见
        });
      } else {
        dynamicLayerList.value.push({
          name: layerName,                 // 图层名称
          url: `/geoserver/wms`,          // WMS服务URL
          visible: false,                 // 默认隐藏
        });
      }
    });

    // ========== 加载图层组 ==========
    
    // 获取所有图层组列表
    let groups = await geoServerRestApi.layers.getLayerGroups();
    
    // 遍历图层组列表
    for (let group of groups.layerGroups.layerGroup) {
      let groupName = group.name;
      
      // 获取图层组详细信息
      let groupLayers = await geoServerRestApi.layers.getLayerGroup(groupName);
      
      // 创建图层组对象
      let layerGroups = {
        name: groupName,                  // 图层组名称
        layers: [],                       // 图层组内的图层列表
        visible: false,                   // 默认隐藏
      };
      
      // 遍历图层组内的已发布对象
      groupLayers.layerGroup.publishables.published.forEach((layer: any) => {
        // 只处理类型为"layer"的对象，跳过其他类型
        if (layer["@type"] !== "layer") return;

        // 添加图层到图层组
        layerGroups.layers.push({
          name: layer.name,               // 图层名称
          url: `/geoserver/wms`,         // WMS服务URL
          visible: false,                // 默认隐藏
        });
      });
      
      // 将配置好的图层组添加到列表
      dynamicLayerGroupList.value.push(layerGroups);
    }
  } catch (error) {
    // 错误处理：记录加载失败信息
    console.error("Failed to load layers:", error);
  }
});

// ========== AI对话框相关方法 ==========

/**
 * 切换AI对话框显示状态
 */
const toggleChatDialog = () => {
  chatDialogVisible.value = !chatDialogVisible.value;
};

/**
 * 关闭AI对话框
 */
const closeChatDialog = () => {
  chatDialogVisible.value = false;
};

/**
 * 处理AI返回的GeoJSON数据
 * @param geoJson AI返回的GeoJSON对象
 */
const handleGeoJsonReceived = (geoJson) => {
  if (!geoJson || !mapRef.value) return;
  
  try {
    // 获取实际的OpenLayers Map对象
    const map = mapRef.value.map;
    
    if (!map) {
      console.error('无法获取地图实例');
      return;
    }
    
    // 如果之前存在GeoJSON图层，先移除
    if (geoJsonLayer) {
      map.removeLayer(geoJsonLayer);
    }
    
    // 创建GeoJSON格式解析器
    const format = new GeoJSON();
    
    // 创建向量数据源
    const source = new VectorSource({
      features: format.readFeatures(geoJson, {
        featureProjection: 'EPSG:4326'
      })
    });
    
    // 创建样式
    const style = new Style({
      stroke: new Stroke({
        color: 'red',
        width: 2
      }),
      fill: new Fill({
        color: 'rgba(255, 0, 0, 0.1)'
      }),
      image: new Circle({
        radius: 8,
        fill: new Fill({
          color: 'red'
        }),
        stroke: new Stroke({
          color: 'white',
          width: 2
        })
      })
    });
    
    // 创建向量图层
    geoJsonLayer = new VectorLayer({
      source: source,
      style: style
    });
    
    // 添加图层到地图
    map.addLayer(geoJsonLayer);
    
    // 定位到GeoJSON数据
    fitToGeoJsonData(geoJson);
    
  } catch (error) {
    console.error('处理GeoJSON数据失败:', error);
  }
};

/**
 * 将地图视图定位到GeoJSON数据范围
 * @param geoJson GeoJSON对象
 */
const fitToGeoJsonData = (geoJson) => {
  if (!mapRef.value || !geoJson) return;
  
  try {
    // 获取实际的OpenLayers Map对象
    const map = mapRef.value.map;
    
    if (!map) {
      console.error('无法获取地图实例');
      return;
    }
    
    // 计算GeoJSON数据的边界框
    const bounds = calculateGeoJsonBounds(geoJson);
    
    if (bounds) {
      // 设置地图视图以适应边界框
      const view = map.getView();
      
      // 计算中心点
      const centerLon = (bounds.minLon + bounds.maxLon) / 2;
      const centerLat = (bounds.minLat + bounds.maxLat) / 2;
      
      // 计算合适的缩放级别
      const lonDiff = bounds.maxLon - bounds.minLon;
      const latDiff = bounds.maxLat - bounds.minLat;
      const maxDiff = Math.max(lonDiff, latDiff);
      
      let zoomLevel = 10;
      if (maxDiff < 0.01) zoomLevel = 15;
      else if (maxDiff < 0.1) zoomLevel = 12;
      else if (maxDiff < 1) zoomLevel = 9;
      else if (maxDiff < 5) zoomLevel = 7;
      else zoomLevel = 5;
      
      // 设置地图中心和缩放级别
      view.setCenter([centerLon, centerLat]);
      view.setZoom(zoomLevel);
    }
  } catch (error) {
    console.error('定位到GeoJSON数据失败:', error);
  }
};

/**
 * 计算GeoJSON数据的边界框
 * @param geoJson GeoJSON对象
 * @returns 边界框对象或null
 */
const calculateGeoJsonBounds = (geoJson) => {
  try {
    let minLon = Infinity, maxLon = -Infinity;
    let minLat = Infinity, maxLat = -Infinity;
    
    const processCoordinates = (coords, type) => {
      if (type === 'Point') {
        const [lon, lat] = coords;
        minLon = Math.min(minLon, lon);
        maxLon = Math.max(maxLon, lon);
        minLat = Math.min(minLat, lat);
        maxLat = Math.max(maxLat, lat);
      } else if (type === 'Polygon') {
        coords[0].forEach(([lon, lat]) => {
          minLon = Math.min(minLon, lon);
          maxLon = Math.max(maxLon, lon);
          minLat = Math.min(minLat, lat);
          maxLat = Math.max(maxLat, lat);
        });
      }
    };
    
    if (geoJson.type === 'FeatureCollection') {
      geoJson.features.forEach(feature => {
        processCoordinates(feature.geometry.coordinates, feature.geometry.type);
      });
    } else if (geoJson.type === 'Feature') {
      processCoordinates(geoJson.geometry.coordinates, geoJson.geometry.type);
    }
    
    if (minLon !== Infinity) {
      return { minLon, maxLon, minLat, maxLat };
    }
    
    return null;
  } catch (error) {
    console.error('计算边界框失败:', error);
    return null;
  }
};
</script>

<style scoped>
/* 地图容器样式 */
#map {
  width: 100%;      /* 宽度占满父容器 */
  height: 100%;     /* 高度占满父容器 */
  position: absolute; /* 绝对定位 */
  top: 0;           /* 顶部对齐 */
  left: 0;          /* 左侧对齐 */
}

/* AI对话框按钮样式 */
.ai-chat-button {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 999;
  background: #3498db;
  color: white;
  border: none;
  border-radius: 25px;
  padding: 12px 20px;
  font-size: 16px;
  font-weight: 500;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  gap: 8px;
}

.ai-chat-button:hover {
  background: #2980b9;
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(52, 152, 219, 0.4);
}

.ai-chat-button:active {
  transform: translateY(0);
}
</style>